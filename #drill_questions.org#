* Drill Questions

* Question 1                                                          :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       fdc59a89-0ca4-4a69-8949-d401a776681c
  :END:
** Front
   Do some research on al-Khorezmi (also al-Khwarizmi), the man from whose name the word "algorithm" is derived. In particular, you should learn what the origins of the words "algorithm" and "algebra" have in common.
** Back
   Al-Khwarizmi (9th century C.E.) was a great Arabic scholar, most famous for his algebra textbook. In fact, the word "algebra" is derived from the Arabic title of this book while the word "algorithm" is derived from a translation of Al-Khwarizmi's last name.

* Question 2                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       b80b3e54-d778-4d1a-9100-45a3621c42bd
  :END:
** Front
   Given that the official purpose of the U.S. patent system is the promotion of the “useful arts,” do you think algorithms are patentable in this country? Should they be?
** Back
   This legal issue has yet to be settled. The current legal state of affairs distinguishes mathematical algorithms, which are not patentable, from other algorithms, which may be patentable if implemented as computer programs (e.g., [Cha00]).

* Question 3                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       ff122daa-5178-46de-a58d-4eb068dbd4b8
  :END:
** Front
   Write down driving directions for going from your school to your home with the precision required by an algorithm.
** Back
   Step-by-step driving directions specific to the participant’s location.

* Question 4                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       bf7d2145-c485-41c5-a235-bb5214faa3b4
  :END:
** Front
   Write down a recipe for cooking your favorite dish with the precision required by an algorithm.
** Back
   Detailed recipe steps written clearly, using no approximations or ambiguities.

* Question 5                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       3dd74bbe-9e3c-4ffd-9876-1ded8b0747a0
  :END:
** Front
   Design an algorithm for computing √n for any positive integer n. Besides assignment and comparison, your algorithm may only use the four basic arithmetical operations.
** Back
   Here is a straightforward algorithm:
   1. Start with an initial guess x = n/2.
   2. Repeat until convergence:
      - Update x = (x + n/x) / 2.
   3. Return x as the approximate square root.
   This algorithm is derived from Newton’s method.

* Question 6                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       d54153b0-975c-42a4-b540-8673af133278
  :END:
** Front
   Find gcd(31415, 14142) by applying Euclid’s algorithm.
** Back
   gcd(31415, 14142) = gcd(14142, 3131) = gcd(3131, 1618) = gcd(1618, 1513) = gcd(1513, 105) = gcd(105, 43) = gcd(43, 19) = gcd(19, 5) = gcd(5, 4) = gcd(4, 1) = gcd(1, 0) = 1.

* Question 7                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       ea84b923-a0a4-41a6-b1cd-88541f795156
  :END:
** Front
   Estimate how many times faster it will be to find gcd(31415, 14142) by Euclid’s algorithm compared with the algorithm based on checking consecutive integers from min{m, n} down to gcd(m, n).
** Back
   Euclid’s algorithm requires 11 divisions. The consecutive integer checking algorithm requires up to 2 * 14142 divisions. Thus, Euclid’s algorithm is approximately 2572 times faster (14142/11).

* Question 8                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       6bfacf37-5cd5-4a6d-91cd-2dd888db6899
  :END:
** Front
   Prove the equality gcd(m, n) = gcd(n, m mod n) for every pair of positive integers m and n.
** Back
   If d divides m and n, then m = qn + r implies that r = m - qn is also divisible by d. Conversely, if d divides n and r, then it divides m = qn + r. This establishes gcd(m, n) = gcd(n, m mod n).

* Question 9                                                            :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       6447543a-5586-404d-bb35-f54ad2dfd970
  :END:
** Front
   What does Euclid’s algorithm do for a pair of numbers in which the first number is smaller than the second one? What is the largest number of times this can happen during the algorithm’s execution on such an input?
** Back
   For m < n, Euclid’s algorithm swaps the numbers so that gcd(m, n) = gcd(n, m). This swap can only happen once during the algorithm’s execution.

* Question 10                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       d446967b-5e9a-4d8a-9d3b-b52c96a6b560
  :END:
** Front
   What is the smallest number of divisions made by Euclid’s algorithm among all inputs 1 ≤ m, n ≤ 10?
** Back
   The smallest number of divisions is 1, occurring when m is a multiple of n (e.g., gcd(4, 2)).

* Question 11                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       6733f84e-533f-4c11-911b-b1345cfa3eb3
  :END:
** Front
   Euclid’s algorithm, as presented in Euclid’s treatise, uses subtractions rather than integer divisions. Write a pseudocode for this version of Euclid’s algorithm.
** Back
   Here is a nonrecursive version:
   Algorithm Euclid2 (m, n)
   //Computes gcd(m, n) by Euclid’s algorithm based on subtractions
   //Input: Two nonnegative integers m and n not both equal to 0
   //Output: The greatest common divisor of m and n
   while n ≠ 0 do
       if m < n swap(m, n)
       m ← m − n
   return m

* Question 12                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       ebc289c4-bab1-43dc-a5b7-7cba5acd4602
  :END:
** Front
   Euclid’s game (see [Bog]) starts with two unequal positive numbers on the board. Two players move in turn. On each move, a player has to write on the board a positive number equal to the difference of two numbers already on the board; this number must be new, i.e., different from all the numbers already on the board. The player who cannot move loses the game. Should you choose to move first or second in this game?
** Back
   It is not too difficult to prove that the integers that can be written on the board are the integers generated by the subtraction version of Euclid's algorithm and only them. Although the order in which they appear on the board may vary, their total number always stays the same: It is equal to m/ gcd(m, n), where m is the maximum of the initial numbers, which includes two integers of the initial pair. Hence, the total number of possible moves is m/ gcd(m, n)−2. Consequently, if m/ gcd(m, n) is odd, one should choose to go first; if it is even, one should choose to go second.

* Question 13                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       44fb645d-aa62-4a52-a5a3-206bb953b5cb
  :END:
** Front
   The extended Euclid's algorithm determines not only the greatest common divisor d of two positive integers m and n but also integers (not necessarily positive) x and y, such that mx + ny = d.
** Back
   The extended algorithm maintains additional variables to track coefficients:
   1. Initialize: x₁=1, y₁=0, x₂=0, y₂=1
   2. While n≠0:
      - q = ⌊m/n⌋
      - r = m - qn
      - x = x₁ - qx₂
      - y = y₁ - qy₂
      - m = n, n = r
      - x₁ = x₂, x₂ = x
      - y₁ = y₂, y₂ = y
   3. Return (d=m, x=x₁, y=y₁)

* Question 14                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       1f34d714-f3d9-46a8-8ca9-7ffe4169e0fe
  :END:
** Front
   Look up a description of the extended Euclid’s algorithm (see, e.g., [KnuI], p. 13) and implement it in the language of your choice.
** Back
   n/a

* Question 15                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       8fe2f295-678d-43ae-9b22-349a96308381
  :END:
** Front
   Modify your program for finding integer solutions to the Diophantine equation ax + by = c with any set of integer coefficients a, b, and c.
** Back
   n/a

* Question 16                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       4554b3ac-1c00-4738-957a-67700e711003
  :END:
** Front
   Locker doors There are n lockers in a hallway numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker #1. On the ith pass, i = 1, 2, ..., n, you toggle the door of every ith locker: if the door is closed, you open it, if it is open, you close it. For example, after the first pass every door is open; on the second pass you only toggle the even-numbered lockers (#2, #4, ...) so that after the second pass the even doors are closed and the odd ones are opened; the third time through you close the door of locker #3 (opened from the first pass), open the door of locker #6 (closed from the second pass), and so on. After the last pass, which locker doors are open and which are closed? How many of them are open?
** Back
   Since all the doors are initially closed, a door will be open after the last pass if and only if it is toggled an odd number of times. Door i (1 ≤ i ≤ n) is toggled on pass j (1 ≤ j ≤ n) if and only if j divides i. Hence, the total number of times door i is toggled is equal to the number of its divisors. Note that if j divides i, i.e. i = jk, then k divides i too. Hence all the divisors of i can be paired (e.g., for i = 12, such pairs are 1 and 12, 2 and 6, 3 and 4) unless i is a perfect square (e.g., for i = 16, 4 does not have another divisor to be matched with). This implies that i has an odd number of divisors if and only if it is a perfect square, i.e., i = j². Hence doors that are in the positions that are perfect squares and only such doors will be open after the last pass. The total number of such positions not exceeding n is equal to √n: these numbers are the squares of the positive integers between 1 and √n inclusively.

* Question 17                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       1e1cca23-26f5-4dc7-ad61-94ca66dd55a8
  :END:
** Front
   Old World puzzle A peasant finds himself on a riverbank with a wolf, a goat, and a head of cabbage. He needs to transport all three to the other side of the river in his boat. However, the boat has room for only the peasant himself and one other item (either the wolf, the goat, or the cabbage). In his absence, the wolf would eat the goat, and the goat would eat the cabbage. Solve this problem for the peasant or prove it has no solution. (Note: The peasant is a vegetarian but does not like cabbage and hence can eat neither the goat nor the cabbage to help him solve the problem. And it goes without saying that the wolf is a protected species.)
** Back
   Solution:
   1. Take goat across (wolf and cabbage safe)
   2. Return empty
   3. Take cabbage across
   4. Return with goat
   5. Take wolf across (cabbage safe)
   6. Return empty
   7. Take goat across
   All items are now safely across.

* Question 18                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       a4c8195a-e48a-4861-abe9-cbabc8bc739a
  :END:
** Front
   New World puzzle There are four people who want to cross a bridge; they all begin on the same side. You have 17 minutes to get them all across to the other side. It is night, and they have one flashlight. A maximum of two people can cross the bridge at one time. Any party that crosses, either one or two people, must have the flashlight with them. The flashlight must be walked back and forth; it cannot be thrown, for example. Person 1 takes 1 minute to cross the bridge, person 2 takes 2 minutes, person 3 takes 5 minutes, and person 4 takes 10 minutes. A pair must walk together at the rate of the slower person's pace. For example, if person 1 and person 4 walk across first, 10 minutes have elapsed when they get to the other side of the bridge. If person 4 returns the flashlight, a total of 20 minutes have passed and you have failed the mission. (Note: According to a rumor on the Internet, interviewers at a well-known software company located near Seattle have given this problem to interviewees.)
** Back
   Solution (17 minutes):
   1. People 1 & 2 cross (2 min)
   2. Person 1 returns (1 min)
   3. People 3 & 4 cross (10 min)
   4. Person 2 returns (2 min)
   5. People 1 & 2 cross (2 min)
   Total: 17 minutes

* Question 19                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       14dba247-7835-4901-8b13-d8cf734e2705
  :END:
** Front
   Which of the following formulas can be considered an algorithm for computing the area of a triangle whose side lengths are given positive numbers a, b, and c?
   a. S = p(p − a)(p − b)(p − c), where p = (a + b + c)/2
   b. S = 1/2 bc sin A, where A is the angle between sides b and c
   c. S = 1/2 aha, where ha is the height to base a
** Back
   Only formula (a) can be considered an algorithm since it uses only the given side lengths. Formula (b) requires angle A which is not given. Formula (c) requires height ha which is not given.

* Question 20                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       f6d75ec8-40c7-481a-abc4-70ff2c832c0c
  :END:
** Front
   Write a pseudocode for an algorithm for finding real roots of equation ax² + bx + c = 0 for arbitrary real coefficients a, b, and c. (You may assume the availability of the square root function sqrt(x).)
** Back
   Algorithm QuadraticRoots(a, b, c)
   if a = 0 then
       if b = 0 then return "no solution" 
       else return -c/b
   discriminant ← b² - 4ac
   if discriminant < 0 then return "no real roots"
   if discriminant = 0 then return -b/(2a)
   x1 ← (-b + sqrt(discriminant))/(2a)
   x2 ← (-b - sqrt(discriminant))/(2a)
   return x1, x2

* Question 21                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       d7dea634-3441-4f03-b13c-0818c1755b18
  :END:
** Front
   Describe the standard algorithm for finding the binary representation of a positive decimal integer
   a. in English.
   b. in a pseudocode.
** Back
   a. English description:
      - Repeatedly divide the number by 2
      - Keep track of remainders (0 or 1)
      - Reverse the sequence of remainders
   b. Pseudocode:
   Algorithm DecimalToBinary(n)
   //Input: Positive decimal integer n
   //Output: Binary representation as string
   result ← empty string
   while n > 0 do
       remainder ← n mod 2
       prepend remainder to result
       n ← n div 2
   return result

* Question 22                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       1729f3e2-02c7-4257-9b51-c2a892e79591
  :END:
** Front
   Describe the algorithm used by your favorite ATM machine in dispensing cash. (You may give your description in either English or a pseudocode, whichever you find more convenient.)
** Back
   Algorithm ATMDispense(amount)
   //Input: Amount to withdraw
   //Available bills: $100, $50, $20, $10, $5
   remaining ← amount
   while remaining > 0 do
       if remaining ≥ 100 then
           dispense $100 bill
           remaining ← remaining - 100
       else if remaining ≥ 50 then
           dispense $50 bill
           remaining ← remaining - 50
       else if remaining ≥ 20 then
           dispense $20 bill
           remaining ← remaining - 20
       else if remaining ≥ 10 then
           dispense $10 bill
           remaining ← remaining - 10
       else
           dispense $5 bill
           remaining ← remaining - 5
   return success

* Question 23                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       487a9372-9768-4d6e-bc66-7a17df10ee22
  :END:
** Front
   a. Can the problem of computing the number π be solved exactly?
   b. How many instances does this problem have?
   c. Look up an algorithm for this problem on the World Wide Web
** Back
   a. No, π cannot be computed exactly as it is an irrational number with infinite decimal places
   b. One instance - π is a mathematical constant
   c. Common algorithms:
      - Leibniz formula: π/4 = 1 - 1/3 + 1/5 - 1/7 + ...
      - Monte Carlo method: Using random points in a square/circle
      - Ramanujan's formula: Rapid convergence series
      - Archimedes' method: Using inscribed/circumscribed polygons

* Question 24                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       fc6515b4-8720-430f-add5-6627d2a376e5
  :END:
** Front
   Give an example of a problem other than computing the greatest common divisor for which you know more than one algorithm. Which of them is simpler? Which is more efficient?
** Back
   Example: Sorting an array
   1. Bubble Sort:
      - Simpler to implement
      - O(n²) time complexity
      - Less efficient
   2. Merge Sort:
      - More complex implementation
      - O(n log n) time complexity
      - More efficient
   Bubble Sort is simpler but Merge Sort is more efficient.

* Question 25                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       1ad60dd8-14f2-4e01-9dec-2b1dfffe769b
  :END:
** Front
   Consider the following algorithm for finding the distance between the two closest elements in an array of numbers.
   Algorithm MinDistance(A[0..n − 1])
   //Input: Array A[0..n − 1] of numbers
   //Output: Minimum distance between two of its elements
   dmin ← ∞
   for i ← 0 to n − 1 do
   for j ← 0 to n − 1 do
   if i = j and |A[i] − A[j]| < dmin
   dmin ← |A[i] − A[j]|
   return dmin
   Make as many improvements as you can in this algorithmic solution to the problem. (If you need to, you may change the algorithm altogether; if not, improve the implementation given.)
** Back
   Improved algorithm:
   Algorithm BetterMinDistance(A[0..n-1])
   //Input: Array A[0..n-1] of numbers
   if n < 2 return ∞
   Sort(A)  // O(n log n)
   dmin ← ∞
   for i ← 1 to n-1 do  // O(n)
       if |A[i] - A[i-1]| < dmin
           dmin ← |A[i] - A[i-1]|
   return dmin
   Improvements:
   1. Eliminated redundant comparisons
   2. Avoided self-comparisons
   3. Reduced complexity from O(n²) to O(n log n)

* Question 26                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       8c57d09b-162c-402f-80c7-57ecf457f4b6
  :END:
** Front
   One of the most influential books on problem solving, titled How To Solve It [Pol57], was written by the Hungarian-American mathematician George Polya (1887—1985). Polya summarized his ideas in a four-point summary. Find this summary on the Web or, better yet, in his book, and compare it with the plan outlined in Section 1.2. What do they have in common? How are they different?
** Back
   Comparison of approaches:
   1. Common elements:
      - Both emphasize understanding the problem first
      - Both include planning/strategy phase
      - Both include implementation/execution
      - Both include verification/review
   2. Key differences:
      - Polya's approach more general (for all problem types)
      - Section 1.2 more specific to algorithmic problems
      - Polya emphasizes "looking back" more strongly
      - Section 1.2 focuses more on efficiency analysis

* Question 27                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       2dd09130-2918-4ee9-b358-69618f2a091e
  :END:
** Front
   Name the algorithms for the searching problem that you already know. Give a good succinct description of each algorithm in English. (If you know no such algorithms, use this opportunity to design one.)
** Back
   Common searching algorithms include:
   1. Sequential (Linear) Search: Scan each element in sequence until target is found. Simple but O(n) time complexity.
   2. Binary Search: For sorted arrays, repeatedly divide search interval in half. O(log n) time complexity.
   3. Hash-based Search: Use hash function to directly access elements. Average O(1) time complexity.
   4. Interpolation Search: Like binary search but estimates position based on values. Good for uniformly distributed data.

* Question 28                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       c25e8ed9-9927-40a9-b009-a9adfd08a27e
  :END:
** Front
   Design a simple algorithm for the string-matching problem
** Back
   Here's a simple string-matching algorithm:
   Algorithm StringMatch(text, pattern)
   //Input: text string of length n, pattern string of length m
   //Output: index of first match or -1 if not found
   for i ← 0 to n-m do
       match ← true
       for j ← 0 to m-1 do
           if text[i+j] ≠ pattern[j] then
               match ← false
               break
       if match then return i
   return -1

* Question 29                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       3b9eb67f-0217-4260-882d-fd3bd2907966
  :END:
** Front
   Consider the following problem: Design an algorithm to determine the best route for a subway passenger to take from one designated station to another in a well-developed subway system similar to those in such cities as Washington, D.C., and London, UK.
   a. The problem's statement is somewhat vague, which is typical of real-life problems. In particular, what reasonable criterion can be used for defining the "best" route?
   b. How would you model this problem by a graph?
** Back
   a. Reasonable criteria for "best" route could include:
      - Minimum total travel time
      - Minimum number of transfers
      - Minimum walking distance between transfers
      - Combination of above factors weighted appropriately
   b. Graph modeling:
      - Vertices: Subway stations
      - Edges: Direct connections between stations
      - Edge weights could represent:
        * Travel time between stations
        * Transfer penalties
        * Distance
      - Multiple edges for different lines
      - Can use Dijkstra's algorithm to find optimal path

* Question 30                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       7b1edcf4-b1a8-4dd7-b735-853ef292a1b8
  :END:
** Front
   a. Rephrase the traveling salesman problem in combinatorial object terms.
   b. Rephrase the graph-coloring problem in combinatorial object terms.
** Back
   a. Traveling Salesman Problem:
      - Find permutation of n cities
      - Minimizes total distance
      - Combinatorial object: permutation of n elements
      - Size of search space: n!
   b. Graph Coloring Problem:
      - Find assignment of k colors to n vertices
      - Combinatorial object: k-ary string of length n
      - Size of search space: k^n
      - Must satisfy adjacent vertex constraints

* Question 31                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       5814162b-d523-4be0-8ecc-13f2a5df309d
  :END:
** Front
   Design an algorithm for the following problem: Given a set of n points in the Cartesian plane, determine whether all of them lie on the same circumference.
** Back
   Algorithm CheckCircumference(points[1..n]):
   1. If n ≤ 3: return true
   2. Find first three non-collinear points p1, p2, p3
   3. Calculate circle center (h,k) and radius r:
      - Use equations: (x-h)² + (y-k)² = r²
      - Solve using three points
   4. For each remaining point (x,y):
      - Check if (x-h)² + (y-k)² = r²
      - If not equal, return false
   5. Return true
   Time complexity: O(n)

* Question 32                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       5286a6ec-87e3-4008-8c12-f7f44ed3a7f9
  :END:
** Front
   Write a program that reads as its inputs the (x, y) coordinates of the endpoints of two line segments P1Q1 and P2Q2 and determines whether the segments have a common point.
** Back
   Algorithm LineIntersection(P1, Q1, P2, Q2):
   1. Check if lines intersect:
      - Calculate orientations using cross products
      - Check if orientations indicate intersection
   2. If lines intersect:
      - Calculate intersection point
      - Verify point lies on both segments
   3. Handle special cases:
      - Collinear segments
      - Overlapping segments
   4. Return true if common point exists
   Time complexity: O(1)

* Question 33                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       2a1100af-bcae-4b38-bb7f-2af6a9637f22
  :END:
** Front
   Describe how one can implement each of the following operations on an array so that the time it takes does not depend on the array's size n.
   a. Delete the ith element of an array (1 ≤ i ≤ n).
   b. Delete the ith element of a sorted array (the remaining array has to stay sorted, of course).
** Back
   a. Unsorted array O(1) deletion:
      - Swap element at i with last element
      - Decrease array size counter
      - Trade-off: Loses original order
   b. Sorted array O(1) deletion:
      - Use boolean array for deletion flags
      - Mark element i as deleted
      - Maintain count of valid elements
      - Trade-offs:
        * Extra space for flags
        * May need periodic cleanup
        * Must skip deleted elements in traversal

* Question 34                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       f8510e8f-a1e3-4c2d-a11e-f04f4b613b7e
  :END:
** Front
   If you have to solve the searching problem for a list of n numbers, how can you take advantage of the fact that the list is known to be sorted? Give separate answers for
   a. lists represented as arrays.
   b. lists represented as linked lists
** Back
   a. Arrays:
      - Use binary search O(log n)
      - Random access enables efficient division
      - Much faster than sequential search O(n)
   b. Linked Lists:
      - Cannot do binary search (no random access)
      - Can still improve on basic sequential search:
        * Stop when current > target
        * Average case better than unsorted
      - Still O(n) but with smaller constant

* Question 35                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       c13001ba-b3a1-4166-8368-697261b7ddb2
  :END:
** Front
   a. Show the stack after each operation of the following sequence that starts with the empty stack:
   push(a), push(b), pop, push(c), push(d), pop
   b. Show the queue after each operation of the following sequence that starts with the empty queue:
   enqueue(a), enqueue(b), dequeue, enqueue(c), enqueue(d), dequeue
** Back
   a. Stack operations:
      1. push(a): [a]
      2. push(b): [a,b]
      3. pop: [a]
      4. push(c): [a,c]
      5. push(d): [a,c,d]
      6. pop: [a,c]
   b. Queue operations:
      1. enqueue(a): [a]
      2. enqueue(b): [a,b]
      3. dequeue: [b]
      4. enqueue(c): [b,c]
      5. enqueue(d): [b,c,d]
      6. dequeue: [c,d]

* Question 36                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       d8da62b6-bbc1-4b29-9841-23606b236237
  :END:
** Front
   a. Let A be the adjacency matrix of an undirected graph. Explain what property of the matrix indicates that
   i. the graph is complete.
   ii. the graph has a loop, i.e., an edge connecting a vertex to itself.
   iii. the graph has an isolated vertex, i.e., a vertex with no edges incident to it.
   b. Answer the same questions for the adjacency list representation.
** Back
   a. Adjacency Matrix properties:
      i. Complete graph: All entries are 1 except diagonal
      ii. Loop: Non-zero element on diagonal (A[i,i] = 1)
      iii. Isolated vertex: Row/column i contains all zeros
   b. Adjacency List properties:
      i. Complete graph: Each vertex list has n-1 entries
      ii. Loop: Vertex appears in its own adjacency list
      iii. Isolated vertex: Empty adjacency list for that vertex

* Question 37                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       6e7bf857-c45a-4258-8d3b-7850f1fc0aa7
  :END:
** Front
   Give a detailed description of an algorithm for transforming a free tree into a tree rooted at a given vertex of the free tree.
** Back
   Algorithm RootTree(tree, root):
   1. Use BFS or DFS starting from root vertex
   2. For each vertex visited:
      - Set its parent as the vertex it was discovered from
      - Add it to children list of its parent
   3. Remove bidirectional edges from original tree
   4. Replace with directed edges from parent to children
   Time complexity: O(V + E) where V is vertices, E is edges

* Question 38                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       5f04f112-fb35-4d02-92b8-537e5e62dee3
  :END:
** Front
   Prove the inequalities that bracket the height of a binary tree with n vertices:
   log2 n ≤ h ≤ n − 1.
** Back
   Proof:
   1. Lower bound (log2 n ≤ h):
      - Each level i has at most 2^i nodes
      - Total nodes n ≤ 2^(h+1) - 1
      - Therefore n + 1 ≤ 2^(h+1)
      - Taking log2: log2(n+1) - 1 ≤ h
      - Thus log2 n ≤ h
   2. Upper bound (h ≤ n-1):
      - Each level must have at least 1 node
      - Height h means h+1 levels
      - Therefore n ≥ h+1
      - Thus h ≤ n-1

* Question 39                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       d02793ec-f4a9-4350-afd9-c3229c8ab09d
  :END:
** Front
   Indicate how the ADT priority queue can be implemented as
   a. an (unsorted) array.
   b. a sorted array.
   c. a binary search tree.
** Back
   a. Unsorted array implementation:
      - Insert: O(1) - add to end
      - DeleteMax: O(n) - scan for maximum
      - Space: O(n)
   b. Sorted array implementation:
      - Insert: O(n) - maintain sorted order
      - DeleteMax: O(1) - remove from end
      - Space: O(n)
   c. Binary search tree implementation:
      - Insert: O(log n) average case
      - DeleteMax: O(log n)
      - Space: O(n)

* Question 40                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       3d400fd8-5efc-4f96-ad36-11b3da064e12
  :END:
** Front
   How would you implement a dictionary of a reasonably small size n if you knew that all its elements are distinct (e.g., names of 50 states of the United States)? Specify an implementation of each dictionary operation.
** Back
   For a small dictionary (n=50):
   1. Use a simple array implementation
   2. Operations:
      - Search: Binary search O(log n)
      - Insert: Maintain sorted order O(n)
      - Delete: O(n)
      - Space: O(n)
   3. Justification:
      - Small n makes linear operations acceptable
      - Simple implementation reduces overhead
      - Binary search still efficient for lookups

* Question 41                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       2c22cac0-c445-4d2c-b1f3-89c746163d53
  :END:
** Front
   For each of the following applications, indicate the most appropriate data structure:
   a. answering telephone calls in the order of their known priorities.
   b. sending backlog orders to customers in the order they have been received.
   c. implementing a calculator for computing simple arithmetical expressions.
** Back
   a. Telephone calls by priority:
      - Use: Priority Queue
      - Reason: Efficiently handles varying priorities
   b. Backlog orders:
      - Use: Queue (FIFO)
      - Reason: First-come-first-served order
   c. Calculator expressions:
      - Use: Stack
      - Reason: Handles operator precedence and nested expressions

* Question 42                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       bf43a59b-ca4c-4d5d-aa27-930d4cfc7c77
  :END:
** Front
   Anagram checking Design an algorithm for checking whether two given words are anagrams, i.e., whether one word can be obtained by permuting the letters of the other. (For example, the words tea and eat are anagrams.)
** Back
   Algorithm CheckAnagram(word1, word2):
   1. If lengths different, return false
   2. Create array/map freq[26] initialized to 0
   3. For each char c in word1:
      - freq[c - 'a']++
   4. For each char c in word2:
      - freq[c - 'a']--
   5. Check if all freq values are 0
   Time complexity: O(n)
   Space complexity: O(1)

* Question 43                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       e222e894-0d4f-4f42-85e9-84fc966fbcc4
  :END:
** Front
   For each of the following algorithms, indicate (i) a natural size metric for its inputs; (ii) its basic operation; (iii) whether the basic operation count can be different for inputs of the same size:
   a. computing the sum of n numbers
   b. computing n!
   c. finding the largest element in a list of n numbers
   d. Euclid’s algorithm
   e. sieve of Eratosthenes
   f. pen-and-pencil algorithm for multiplying two n-digit decimal integers
** Back
   a. Sum of n numbers:
      - Size metric: n (number of elements)
      - Basic operation: addition
      - Count always same for given size: Yes
   b. Computing n!:
      - Size metric: n
      - Basic operation: multiplication
      - Count always same: Yes
   c. Finding largest element:
      - Size metric: n
      - Basic operation: comparison
      - Count always same: Yes
   d. Euclid's algorithm:
      - Size metric: number of digits in larger number
      - Basic operation: division/remainder
      - Count varies with input values: Yes
   e. Sieve of Eratosthenes:
      - Size metric: n (upper bound)
      - Basic operation: marking multiples
      - Count always same: Yes
   f. Multiplication of n-digit integers:
      - Size metric: n (digits)
      - Basic operation: single-digit multiplication
      - Count always same: Yes

* Question 44                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       72e2abe1-ba88-4517-b316-86b556850951
  :END:
** Front
   a. Consider the definition-based algorithm for adding two n-by-n matrices. What is its basic operation? How many times is it performed as a function of the matrix order n? As a function of the total number of elements in the input matrices?
   b. Answer the same questions for the definition-based algorithm for matrix multiplication.
** Back
   a. Matrix Addition:
      - Basic operation: Addition of corresponding elements
      - Count: n² operations (one per matrix element)
      - As function of total elements N = n²: N operations
   b. Matrix Multiplication:
      - Basic operation: Multiplication of element pairs
      - Count: n³ operations (n multiplications for each of n² elements)
      - As function of total elements N = n²: N^(3/2) operations

* Question 45                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       3b70538c-f7c0-4ef9-a87b-109a02406047
  :END:
** Front
   Consider a variation of sequential search that scans a list to return the number of occurrences of a given search key in the list. Will its efficiency differ from the efficiency of classic sequential search?
** Back
   - The efficiency will be different in the best case (same as classic)
   - Must always scan entire list in worst and average cases
   - Classic search can stop at first match
   - Time complexity:
     * Best case: O(1) - same as classic
     * Worst case: O(n) - must scan entire list
     * Average case: O(n) - must scan entire list

* Question 46                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       4e26d827-8318-4433-b6f0-bec50c7c1d22
  :END:
** Front
   a. Glove selection There are 22 gloves in a drawer: 5 pairs of red gloves, 4 pairs of yellow, and 2 pairs of green. You select the gloves in the dark and can check them only after a selection has been made. What is the smallest number of gloves you need to select to have at least one matching pair in the best case? in the worst case? (after [Mos01], #18)
   b. Missing socks Imagine that after washing 5 distinct pairs of socks, you discover that two socks are missing. Of course, you would like to have the largest number of complete pairs remaining. Thus, you are left with 4 complete pairs in the best-case scenario and with 3 complete pairs in the worst case. Assuming that the probability of disappearance for each of the 10 socks is the same, find the probability of the best-case scenario; the probability of the worst-case scenario; the number of pairs you should expect in the average case. (after [Mos01], #48)
** Back
   a. Glove selection:
      - Best case: 2 gloves (same color)
      - Worst case: 12 gloves (could get one of each color first)
   b. Missing socks:
      - Best case probability: C(2,2) * C(8,0) / C(10,2) = 28/45
      - Worst case probability: C(2,1) * C(8,1) / C(10,2) = 16/45
      - Expected pairs: (4*28/45 + 3*16/45) = 3.62 pairs

* Question 47                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       48f340d2-f521-4c22-a87a-80c76a1b8097
  :END:
** Front
   a. Prove formula (2.1) for the number of bits in the binary representation of a positive integer.
   b. What would be the analogous formula for the number of decimal digits?
   c. Explain why, within the accepted analysis framework, it does not matter whether we use binary or decimal digits in measuring n’s size.
** Back
   a. Binary representation:
      - For n > 0, ⌊log₂n⌋ + 1 bits needed
      - Proof: 2^k ≤ n < 2^(k+1) where k = ⌊log₂n⌋
   b. Decimal representation:
      - For n > 0, ⌊log₁₀n⌋ + 1 digits needed
   c. Both are logarithmic:
      - log₂n = log₁₀n / log₁₀2
      - Differ only by constant factor
      - Same asymptotic complexity class

* Question 48                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       b461d7dc-d072-43d2-a375-3e9f5cecadf0
  :END:
** Front
   Suggest how any sorting algorithm can be augmented in a way to make the best-case count of its key comparisons equal to just n − 1 (n is a list’s size, of course). Do you think it would be a worthwhile addition to any sorting algorithm?
** Back
   - Add initial pass to check if array is sorted
   - Requires n-1 comparisons
   - If sorted, stop; if not, proceed with normal sort
   - Not worthwhile because:
     * Adds overhead to already-sorted cases
     * Most real data is not perfectly sorted
     * Minimal benefit for random data

* Question 49                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       63e8f2b6-c717-4a48-afac-a533ee7785c2
  :END:
** Front
   Gaussian elimination, the classic algorithm for solving systems of n linear equations in n unknowns, requires about 1/3n³ multiplications, which is the algorithm’s basic operation.
   a. How much longer should you expect Gaussian elimination to work on a system of 1000 equations versus a system of 500 equations?
   b. You are considering buying a computer that is 1000 times faster than the one you currently have. By what factor will the faster computer increase the sizes of systems solvable in the same amount of time as on the old computer?
** Back
   a. Time comparison:
      - T(1000)/T(500) = 1000³/500³ = 8
      - Will take 8 times longer
   b. Size increase:
      - New_size³/Old_size³ = 1000
      - New_size = Old_size * ∛1000 ≈ 10
      - Can solve problems ~10 times larger

* Question 50                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       dba5769b-9528-4b54-9595-f6e94b100700
  :END:
** Front
   Indicate whether the first function of each of the following pairs has a smaller, same, or larger order of growth (to within a constant multiple) than the second function.
   a. n(n + 1) and 2000n²
   b. 100n² and 0.01n³
   c. log₂n and ln n
   d. log₂² n and log₂ n²
   e. 2^(n−1) and 2^n
   f. (n − 1)! and n!
** Back
   a. n(n + 1) and 2000n²: Same order (both Θ(n²))
   b. 100n² and 0.01n³: n² is smaller (n³ dominates)
   c. log₂n and ln n: Same order (differ by constant)
   d. log₂²n and log₂(n²): Same order (log₂(n²) = 2log₂n)
   e. 2^(n-1) and 2^n: Same order (differ by constant factor)
   f. (n-1)! and n!: Same order (differ by factor of n)

* Question 51                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       44b7da6a-f462-433f-98e1-031d67ec28b2
  :END:
** Front
   Invention of chess According to a well-known legend, the game of chess was invented many centuries ago in northwestern India by a sage named Shashi. When he took his invention to his king, the king liked the game so much that he offered the inventor any reward he wanted. Sashi asked for some grain to be obtained as follows: just a single grain of wheat was to be placed on the first square of the chess board, two on the second, four on the third, eight on the fourth, and so on, until all 64 squares had been filled. What would the ultimate result of this algorithm have been?
** Back
   - Each square gets 2^(k-1) grains where k is square number (1 to 64)
   - Total grains = 2⁰ + 2¹ + 2² + ... + 2⁶³
   - Sum = 2⁶⁴ - 1
   - This equals 18,446,744,073,709,551,615 grains
   - Far more wheat than has ever existed on Earth
   - The king could not fulfill this request

* Question 52                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       df7cc12f-93fa-4995-8f7b-4882f152e677
  :END:
** Front
   Use the most appropriate notation among O, Θ, and Ω to indicate the time efficiency class of sequential search (see Section 2.1)
   a. in the worst case.
   b. in the best case.
   c. in the average case
** Back
   a. Worst case: Θ(n) - must scan entire array
   b. Best case: O(1) - first element is target
   c. Average case: Θ(n) - expected to scan half array

* Question 53                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       7c462a9f-c8c2-4d52-afc2-03722f845533
  :END:
** Front
   Use the informal definitions of O, Θ, and Ω to determine whether the following assertions are true or false.
   a. n(n + 1)/2 ∈ O(n³)
   b. n(n + 1)/2 ∈ O(n²)
   c. n(n + 1)/2 ∈ Θ(n³)
   d. n(n + 1)/2 ∈ Ω(n)
** Back
   a. n(n+1)/2 ∈ O(n³): True (quadratic is bounded by cubic)
   b. n(n+1)/2 ∈ O(n²): True (is quadratic)
   c. n(n+1)/2 ∈ Θ(n³): False (not cubic growth)
   d. n(n+1)/2 ∈ Ω(n): True (grows faster than linear)

* Question 54                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       12695b37-32ad-46ab-b78c-e8649877823f
  :END:
** Front
   For each of the following functions, indicate the class Θ(g(n)) the function belongs to. (Use the simplest g(n) possible in your answers.) Prove your assertions.
   a. (n² + 1)¹⁰
   b. √(10n² + 7n + 3)
   c. 2n lg(n + 2)² + (n + 2)² lg n²
   d. 2^(n+1) + 3^(n-1)
   e. log₂ n
** Back
   a. (n² + 1)¹⁰ ∈ Θ(n²⁰)
   b. √(10n² + 7n + 3) ∈ Θ(n)
   c. 2n lg(n + 2)² + (n + 2)² lg n² ∈ Θ(n log² n)
   d. 2^(n+1) + 3^(n-1) ∈ Θ(3^n)
   e. log₂ n ∈ Θ(log n)

* Question 55                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       80793527-e09c-46e5-8cf5-4cf7a053cbb3
  :END:
** Front
   a. Table 2.1 contains values of several functions that often arise in analysis of algorithms. These values certainly suggest that the functions log n, n, n log n, n², n³, 2^n, n! are listed in increasing order of their order of growth. Do these values prove this fact with mathematical certainty?
   b. Prove that the functions are indeed listed in increasing order of their order of growth.
** Back
   a. No, values alone don't prove order with certainty. We need formal mathematical proofs.
   b. Proof using limits:
      1. lim(n→∞) log n/n = 0, so log n < n
      2. lim(n→∞) n/(n log n) = 0, so n < n log n
      3. lim(n→∞) (n log n)/n² = 0, so n log n < n²
      4. lim(n→∞) n²/n³ = 0, so n² < n³
      5. lim(n→∞) n³/2^n = 0, so n³ < 2^n
      6. lim(n→∞) 2^n/n! = 0, so 2^n < n!

* Question 56                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       d75544ba-e879-404d-bf6b-86de1dd2229f
  :END:
** Front
   Order the following functions according to their order of growth (from the lowest to the highest):
   (n−2)!, 5 lg(n+ 100)¹⁰, 2^(2n), 0.001n⁴ + 3n³ + 1, ln² n, √3 n, 3^n
** Back
   Ordered from lowest to highest growth:
   1. 5 lg(n + 100)¹⁰ ∈ Θ(log¹⁰ n)
   2. ln² n ∈ Θ(log² n)
   3. √3 n ∈ Θ(n^(1/2))
   4. 0.001n⁴ + 3n³ + 1 ∈ Θ(n⁴)
   5. 2^(2n) ∈ Θ(2^n)
   6. 3^n ∈ Θ(3^n)
   7. (n-2)! ∈ Θ(n!)

* Question 57                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       3b480e76-ce0f-4fe8-9ccd-82a918862ec1
  :END:
** Front
   a. Prove that every polynomial of degree k, p(n) = a_k n^k + a_(k−1) n^(k−1) + ... + a_0, with a_k > 0 belongs to Θ(n^k).
   b. Prove that exponential functions a^n have different orders of growth for different values of base a > 0.
** Back
   a. Proof for polynomials:
      1. Upper bound: |p(n)| ≤ |a_k|n^k + |a_(k-1)|n^(k-1) + ... + |a_0|
                     ≤ (|a_k| + |a_(k-1)| + ... + |a_0|)n^k = c₁n^k
      2. Lower bound: For large n, |p(n)| ≥ |a_k|n^k/2 = c₂n^k
      Therefore, p(n) ∈ Θ(n^k)
   b. Proof for exponentials:
      For a₁ > a₂ > 0:
      lim(n→∞) (a₂^n)/(a₁^n) = lim(n→∞) (a₂/a₁)^n = 0
      Therefore, a₁^n grows faster than a₂^n

* Question 58                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       2a99237c-5bd0-4379-b383-bbfa570b635d
  :END:
** Front
   Prove (by using the definitions of the notations involved) or disprove (by giving a specific counterexample) the following assertions.
   a. If t(n) ∈ O(g(n)), then g(n) ∈ Ω(t(n)).
   b. Θ(αg(n)) = Θ(g(n)), where α > 0.
   c. Θ(g(n)) = O(g(n)) ∩ Ω(g(n)).
   d. For any two nonnegative functions t(n) and g(n) defined on the set of nonnegative integers, either t(n) ∈ O(g(n)), or t(n) ∈ Ω(g(n)), or both.
** Back
   a. False. Counterexample: t(n) = n, g(n) = n². Here n ∈ O(n²) but n² ∉ Ω(n).
   b. True. Since α is constant, multiplying by it doesn't change asymptotic behavior.
   c. True. By definition, f(n) ∈ Θ(g(n)) means f(n) is both O(g(n)) and Ω(g(n)).
   d. False. Counterexample: t(n) = n for n even, n² for n odd;
            g(n) = n² for n even, n for n odd.

* Question 59                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       ba87b204-4e5f-45a8-854b-828baddc573a
  :END:
** Front
   Prove the section's theorem for
   a. Ω notation.
   b. Θ notation.
** Back
   a. Ω notation proof:
      f(n) ∈ Ω(g(n)) iff g(n) ∈ O(f(n))
      iff ∃c,n₀ > 0: g(n) ≤ cf(n) ∀n ≥ n₀
      iff ∃c,n₀ > 0: f(n) ≥ (1/c)g(n) ∀n ≥ n₀
   b. Θ notation proof:
      f(n) ∈ Θ(g(n)) iff f(n) ∈ O(g(n)) and f(n) ∈ Ω(g(n))
      iff ∃c₁,c₂,n₀ > 0: c₁g(n) ≤ f(n) ≤ c₂g(n) ∀n ≥ n₀

* Question 60                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       ef0c9aed-5962-4d49-a90a-4a2caf163d11
  :END:
** Front
   We mentioned in this section that one can check whether all elements of an array are distinct by a two-part algorithm based on the array's presorting.
   a. If the presorting is done by an algorithm with the time efficiency in Θ(n log n), what will be the time efficiency class of the entire algorithm?
   b. If the sorting algorithm used for presorting needs an extra array of size n, what will be the space efficiency class of the entire algorithm?
** Back
   a. Time efficiency: Θ(n log n)
      - Sorting phase: Θ(n log n)
      - Checking phase: Θ(n)
      - Overall: Θ(n log n) dominates
   b. Space efficiency: Θ(n)
      - Input array: n elements
      - Extra array: n elements
      - Total space: Θ(n)

* Question 61                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       83b146c4-4f30-4496-8a04-96c62bbae0cd
  :END:
** Front
   Door in a wall You are facing a wall that stretches infinitely in both directions. There is a door in the wall, but you know neither how far away nor in which direction. You can see the door only when you are right next to it. Design an algorithm that enables you to reach the door by walking at most O(n) steps where n is the (unknown to you) number of steps between your initial position and the door. [Par95], #652
** Back
   Algorithm FindDoor:
   1. Start at position 0
   2. For i = 0,1,2,3,...
      - Walk 2^i steps right
      - If door found, stop
      - Return to start
      - Walk 2^i steps left
      - If door found, stop
      - Return to start
   Analysis:
   - If door is n steps away
   - Algorithm finds it in ≤ 4n steps
   - Therefore O(n) complexity

* Question 62                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       42f83674-6931-47c1-a9de-3c1a12baa549
  :END:
** Front
   Compute the following sums.
   a. 1+3+5+7+ ... + 999
   b. 2 + 4 + 8 + 16 + ... + 1024
   c. n+1
   i=3 1
   d. n+1
   i=3 i
   e. n−1
   i=0 i(i + 1)
   f. n
   j=1 3j+1
   g. n
   i=1
   n
   j=1 ij
   h. n−1
   i=0 1/i(i + 1)
** Back
   a. The sequence is an arithmetic progression with the first term \( a = 1 \), common difference \( d = 2 \), and the last term \( l = 999 \). Using the formula for the sum of an arithmetic sequence:
   \[ S = \frac{n}{2} (a + l) \], where \( n \) is the number of terms:
   \[ n = \frac{l - a}{d} + 1 = \frac{999 - 1}{2} + 1 = 500 \]
   \[ S = \frac{500}{2} (1 + 999) = 250 \times 1000 = 250,000 \]
   b. The sequence is a geometric progression with \( a = 2 \), \( r = 2 \), and \( l = 1024 \). Using the sum formula for a geometric progression:
   \[ S = a \frac{r^n - 1}{r - 1} \], where \( n \) is the number of terms:
   \[ n = \log_2(1024) = 10 \]
   \[ S = 2 \frac{2^{10} - 1}{2 - 1} = 2 \times (1024 - 1) = 2 \times 1023 = 2046 \]
   c. \(\sum_{i=3}^{n+1} 1 = (n + 1) - 3 + 1 = n - 2 \).
   d. \(\sum_{i=3}^{n+1} i = \frac{(n+1)(n+2)}{2} - \frac{(3)(2)}{2} = \frac{(n+1)(n+2) - 6}{2} \).
   e. \(\sum_{i=0}^{n-1} i(i+1) = \sum_{i=0}^{n-1} (i^2 + i) = \sum_{i=0}^{n-1} i^2 + \sum_{i=0}^{n-1} i = \frac{(n-1)n(2n-1)}{6} + \frac{(n-1)n}{2} = \frac{(n-1)n(2n+2)}{6} = \frac{(n-1)n(n+1)}{3} \).
   f. \(\sum_{j=1}^{n} (3j + 1) = 3\sum_{j=1}^n j + \sum_{j=1}^n 1 = 3 \frac{n(n+1)}{2} + n = \frac{3n(n+1)}{2} + n = \frac{3n^2 + 3n + 2n}{2} = \frac{3n^2 + 5n}{2} \).
   g. \(\sum_{i=1}^{n} \sum_{j=1}^{n} ij = \left(\sum_{i=1}^n i\right) \left(\sum_{j=1}^n j\right) = \left(\frac{n(n+1)}{2}\right)^2 = \frac{n^2(n+1)^2}{4} \).
   h. \(\sum_{i=0}^{n-1} \frac{1}{i(i+1)} = \sum_{i=0}^{n-1} \left(\frac{1}{i} - \frac{1}{i+1}\right) = 1 - \frac{1}{n} = \frac{n-1}{n} \).

* Question 63                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       945b2b3e-8ec0-44f4-ba84-cc6f080d17c0
  :END:
** Front
   Find the order of growth of the following sums.
   a. n−1
   i=0 (i²+1)²
   b. n−1
   i=2 lg i²
   c. n
   i=1(i + 1)2i−1
   d. n−1
   i=0
   i−1
   j=0(i + j)
   Use the Θ(g(n)) notation with the simplest function g(n) possible.
** Back
   a. Θ(n⁵) - The highest power term (i⁴) dominates when expanded
   b. Θ(n log² n) - Sum of logarithmic terms
   c. Θ(2ⁿ) - Exponential growth dominates
   d. Θ(n³) - Nested sum with cubic growth

* Question 64                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       225bc4c0-b51d-474d-bfa5-f0ba477430f9
  :END:
** Front
   The sample variance of n measurements x₁, x₂, ..., xₙ can be computed as
   \(\frac{\sum_{i=1}^{n}(x_i − \bar{x})²}{n − 1}\)
   where \(\bar{x} = \frac{\sum_{i=1}^{n} x_i}{n}\)
   or
   \(\frac{\sum_{i=1}^{n} x²_i − (\sum_{i=1}^{n} x_i)²/n}{n − 1}\).
   Find and compare the number of divisions, multiplications, and additions/subtractions (additions and subtractions are usually bunched together) that are required for computing the variance according to each of these formulas.
** Back
   First formula:
   - Divisions: 2 (mean and final division)
   - Multiplications: n (squaring deviations)
   - Additions/Subtractions: 2n-1 (n-1 for mean sum, n for deviations)
   Second formula:
   - Divisions: 2 (division by n and n-1)
   - Multiplications: n+1 (n squares plus square of sum)
   - Additions/Subtractions: 2n-1 (n-1 for each sum)
   The second formula is generally more efficient.

* Question 65                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       700cd9d4-567c-4add-93fd-9e26af7e36fe
  :END:
** Front
   Consider the following algorithm.
   Algorithm Mystery( n)
   //Input: A nonnegative integer n
   S ← 0
   for i ← 1 to n do
   S ← S + i ∗ i
   return S
   a. What does this algorithm compute?
   b. What is its basic operation?
   c. How many times is the basic operation executed?
   d. What is the efficiency class of this algorithm?
   e. Suggest an improvement or a better algorithm altogether and indicate its efficiency class. If you cannot do it, try to prove that, in fact, it cannot be done.
** Back
   a. Computes sum of squares from 1 to n: 1² + 2² + ... + n²
   b. Basic operation is multiplication (i * i)
   c. Executed n times
   d. Θ(n) time complexity
   e. Improvement: Use the closed formula for sum of squares:
      n(n+1)(2n+1)/6
      This gives Θ(1) time complexity

* Question 66                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       c20bdd64-d6da-4e68-a8b9-a6e78a1def62
  :END:
** Front
   Consider the following algorithm.
   Algorithm Secret(A[0..n − 1])
   //Input: An array A[0..n − 1] of n real numbers
   minval ← A[0]; maxval ← A[0]
   for i ← 1 to n − 1 do
   if A[i] < minval
   minval ← A[i]
   if A[i] > maxval
   maxval ← A[i]
   return maxval − minval
   Answer questions a—e of Problem 4 about this algorithm.
** Back
   a. Computes the range (max - min) of the array.
   b. Basic operation: Comparison.
   c. Executed 2(n-1) times.
   d. Efficiency class: Θ(n).
   e. Optimal as is; cannot be improved beyond linear time.

* Question 67                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       74129f79-bcd1-4796-a8de-24b66220d4b1
  :END:
** Front
   Consider the following algorithm.
   Algorithm Enigma(A[0..n − 1, 0..n − 1])
   //Input: A matrix A[0..n − 1, 0..n − 1] of real numbers
   for i ← 0 to n − 2 do
   for j ← i + 1 to n − 1 do
   if A[i, j] = A[j, i]
   return false
   return true
   Answer the questions a—e of Problem 4 about this algorithm.
** Back
   a. The algorithm returns "true" if its input matrix is symmetric and "false" if it is not.
   b. Comparison of two matrix elements.
   c. Cworst(n) = n−2
   i=0
   n−1
   j=i+1
   1 = n−2
   i=0
   [(n − 1) − (i + 1) + 1)
   = n−2
   i=0
   (n − 1 − i)=(n − 1) + (n − 2) + ... +1= (n−1)n
   2 .
   d. Quadratic: Cworst(n) ∈ Θ(n2) (or C(n) ∈ O(n2)).
   e. The algorithm is optimal because any algorithm that solves this problem must, in the worst case, compare (n − 1)n/2 elements in the uppertriangular part of the matrix with their symmetric counterparts in the lower-triangular part, which is all this algorithm does.

* Question 68                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       398c5d4f-b02e-41e8-b31f-002f290d2fd7
  :END:
** Front
   Improve the implementation of the matrix multiplication algorithm (see Example 3) by reducing the number of additions made by the algorithm. What effect will this change have on the algorithm's efficiency?
** Back
   Replace the body of the j loop by the following fragment:
   C[i, j] ← A[i, 0] ∗ B[0, j]
   for k ← 1 to n − 1 do
   C[i, j] ← C[i, j] + A[i, k] ∗ B[k, j]
   This will decrease the number of additions from n3 to n3 − n2, but the number of multiplications will still be n3. The algorithm's efficiency class will remain cubic.

* Question 69                                                           :drill:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided
  :ID:       5f7510d2-4f82-4857-9f05-4e8dc59d9390
  :END:
** Front
   Solve the following recurrence relations.
   a. x(n) = x(n − 1) + 5 for n > 1, x(1) = 0
   b. x(n)=3x(n − 1) for n > 1, x(1) = 4
   c. x(n) = x(n − 1) + n for n > 0, x(0) = 0
   d. x(n) = x(n/2) + n for n > 1, x(1) = 1 (solve for n = 2k)
   e. x(n) = x(n/3) + 1 for n > 1, x(1) = 1 (solve for n = 3k)
** Back
   a. x(n) = x(n − 1) + 5 for n > 1, x(1) = 0
   x(n) = x(n − 1) + 5
   = [x(n − 2) + 5] + 5 = x(n − 2) + 5 · 2
   = [x(n − 3) + 5] + 5 · 2 = x(n − 3) + 5 · 3
   = ...
   = x(n − i)+5 · i
   = ...
   = x(1) + 5 · (n − 1) = 5(n − 1).
   Note: The solution can also be obtained by using the formula for the n term of the arithmetical progression:
   x(n) = x(1) + d(n − 1) = 0 + 5(n − 1) = 5(n − 1).
   b. x(n)=3x(n − 1) for n > 1, x(1) = 4
   x(n)=3x(n − 1)
   = 3[3x(n − 2)] = 32x(n − 2)
   = 32[3x(n − 3)] = 33x(n − 3)
   = ...
   = 3i
   x(n − i)
   = ...
   = 3n−1x(1) = 4 · 3n−1.
   Note: The solution can also be obtained by using the formula for the n term of the geometric progression:
   x(n) = x(1)qn−1 = 4 · 3n−1.
   c. x(n) = x(n − 1) + n for n > 0, x(0) = 0
   x(n) = x(n − 1) + n
   = [x(n − 2) + (n − 1)] + n = x(n − 2) + (n − 1) + n
   = [x(n − 3) + (n − 2)] + (n − 1) + n = x(n − 3) + (n − 2) + (n − 1) + n
   = ...
   = x(n − i)+(n − i + 1) + (n − i + 2) + ... + n
   = ...
   = x(0) + 1 + 2 + ... + n = n(n + 1)
   2 .
   32
   d. x(n) = x(n/2) + n for n > 1, x(1) = 1 (solve for n = 2k)
   x(2k) = x(2k−1)+2k
   = [x(2k−2)+2k−1]+2k = x(2k−2)+2k−1 + 2k
   = [x(2k−3)+2k−2]+2k−1 + 2k = x(2k−3)+2k−2 + 2k−1 + 2k
   = ...
   = x(2k−i
   )+2k−i+1 + 2k−i+2 + ... + 2k
   = ...
   = x(2k−k)+21 + 22 + ... + 2k =1+21 + 22 + ... + 2k
   = 2k+1 − 1=2 · 2k − 1=2n − 1.
   e. x(n) = x(n/3) + 1 for n > 1, x(1) = 1 (solve for n = 3k)
   x(3k) = x(3k−1)+1
   = [x(3k−2) + 1] + 1 = x(3k−2)+2
   = [x(3k−3) + 1] + 2 = x(3k−3)+3
   = ...
   = x(3k−i
   ) + i
   = ...
   = x(3k−k) + k = x(1) + k = 1 + log3 n.

* Question 70                                                           :drill:
:PROPERTIES:
:ID:       aa46282d-665a-44aa-a591-d0a4b3814d36
:END:
  :PROPERTIES:
  :DRILL_CARD_TYPE: twosided